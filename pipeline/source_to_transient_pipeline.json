{
	"name": "source_to_transient_pipeline",
	"properties": {
		"activities": [
			{
				"name": "SetDatabaseForLoad",
				"type": "SetVariable",
				"dependsOn": [
					{
						"activity": "GetTableMetadata",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"variableName": "database_name",
					"value": {
						"value": "@activity('GetTableMetadata').output.firstRow.system_db",
						"type": "Expression"
					}
				}
			},
			{
				"name": "UpdateMetadata",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "IfAnyPreTransformations",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "AzureSqlSource",
						"sqlReaderQuery": {
							"value": "UPDATE adf_metastore.dbo.table_list SET max_timestamp='@{variables('max_timestamp')}',\nmax_index=@{variables('max_index')},\nprev_max_index=@{activity('GetTableMetadata').output.firstRow.max_index} \nWHERE table_name='@{pipeline().parameters.table_name}'; \nSELECT 1\n",
							"type": "Expression"
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "Metastore",
						"type": "DatasetReference",
						"parameters": {
							"table_name": "''"
						}
					}
				}
			},
			{
				"name": "SetServerForLoad",
				"type": "SetVariable",
				"dependsOn": [
					{
						"activity": "GetTableMetadata",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"variableName": "server_path",
					"value": {
						"value": "@activity('GetTableMetadata').output.firstRow.system_url",
						"type": "Expression"
					}
				}
			},
			{
				"name": "GetTableMetadata",
				"type": "Lookup",
				"dependsOn": [],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "AzureSqlSource",
						"sqlReaderStoredProcedureName": "[dbo].[GetTableMetadata]",
						"storedProcedureParameters": {
							"SourceName": {
								"type": "String",
								"value": {
									"value": "@pipeline().parameters.source",
									"type": "Expression"
								}
							},
							"TableName": {
								"type": "String",
								"value": {
									"value": "@pipeline().parameters.table_name",
									"type": "Expression"
								}
							},
							"Env": {
								"type": "String",
								"value": {
									"value": "@pipeline().globalParameters.environment",
									"type": "Expression"
								}
							},
							"catchup": {
								"type": "String",
								"value": {
									"value": "@pipeline().parameters.catchup",
									"type": "Expression"
								}
							}
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "Metastore_tablelist",
						"type": "DatasetReference"
					}
				}
			},
			{
				"name": "SetDBShemaForLoad",
				"type": "SetVariable",
				"dependsOn": [
					{
						"activity": "GetTableMetadata",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"variableName": "database_schema",
					"value": {
						"value": "@activity('GetTableMetadata').output.firstRow.system_db_schema",
						"type": "Expression"
					}
				}
			},
			{
				"name": "GetTablePreTransformations",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "SourceToTransient",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "AzureSqlSource",
						"sqlReaderStoredProcedureName": "[dbo].[GetPreTransformations]",
						"storedProcedureParameters": {
							"TableName": {
								"type": "String",
								"value": {
									"value": "@pipeline().parameters.table_name",
									"type": "Expression"
								}
							}
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "Metastore",
						"type": "DatasetReference",
						"parameters": {
							"table_name": {
								"value": "@pipeline().parameters.table_name",
								"type": "Expression"
							}
						}
					}
				}
			},
			{
				"name": "IfAnyPreTransformations",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "GetTablePreTransformations",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@equals(activity('GetTablePreTransformations').output.firstRow.table_preTrans,null)",
						"type": "Expression"
					},
					"ifFalseActivities": [
						{
							"name": "DataPreTransformations",
							"type": "DatabricksNotebook",
							"dependsOn": [],
							"policy": {
								"timeout": "7.00:00:00",
								"retry": 0,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"typeProperties": {
								"notebookPath": {
									"value": "@concat(if(equals(pipeline().globalParameters.environment,'dev'),'/Repos/caelum/lowell.caelum.cdp.databricks/','/caelum/'),'adf-pretransformations/adf_preTrans')\n",
									"type": "Expression"
								},
								"baseParameters": {
									"country": {
										"value": "@activity('GetTableMetadata').output.firstRow.country_name",
										"type": "Expression"
									},
									"zone": {
										"value": "@pipeline().globalParameters.transient_zone_name",
										"type": "Expression"
									},
									"source": {
										"value": "@pipeline().parameters.source",
										"type": "Expression"
									},
									"year": {
										"value": "@formatDateTime(variables('date'),'yyyy')",
										"type": "Expression"
									},
									"month": {
										"value": "@formatDateTime(variables('date'),'MM')",
										"type": "Expression"
									},
									"day": {
										"value": "@formatDateTime(variables('date'),'dd')",
										"type": "Expression"
									},
									"table": {
										"value": "@pipeline().parameters.table_name",
										"type": "Expression"
									},
									"file_timestamp": {
										"value": "@formatDateTime(variables('date'),'yyyyMMddhhmmss')",
										"type": "Expression"
									},
									"sql_definitions": {
										"value": "@activity('GetTablePreTransformations').output.firstRow.table_preTrans",
										"type": "Expression"
									}
								}
							},
							"linkedServiceName": {
								"referenceName": "databricks_cs",
								"type": "LinkedServiceReference"
							}
						}
					]
				}
			},
			{
				"name": "GetColumns",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "SetDatabaseForLoad",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "SetDBShemaForLoad",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "GetTableMetadata",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "IfSourceIsNovaRunClientExemptionPipe",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "SqlServerSource",
						"sqlReaderQuery": {
							"value": "SELECT STUFF((  \n     SELECT ',' + COLUMN_NAME\n        FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '@{activity('GetTableMetadata').output.firstRow.table_name}' AND TABLE_SCHEMA = '@{variables('database_schema')}'\n        FOR XML PATH('')\n     ), 1, 1, '') as Columns\n\n",
							"type": "Expression"
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "parameterized_source",
						"type": "DatasetReference",
						"parameters": {
							"schema": "@variables('database_schema')",
							"table_name": "@pipeline().parameters.table_name",
							"server_path": "@variables('server_path')",
							"database_name": {
								"value": "@variables('database_name')",
								"type": "Expression"
							}
						}
					}
				}
			},
			{
				"name": "Run_ClientExemptionSP",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "StageLoad",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "AzureSqlSource",
						"sqlReaderStoredProcedureName": "[dbo].[GetSQLQueryClientExemption_V3]",
						"storedProcedureParameters": {
							"Columns": {
								"type": "String",
								"value": {
									"value": "@activity('GetColumns').output.firstRow.Columns",
									"type": "Expression"
								}
							},
							"DatabaseName": {
								"type": "String",
								"value": {
									"value": "@variables('database_name')",
									"type": "Expression"
								}
							},
							"DatabaseSchema": {
								"type": "String",
								"value": {
									"value": "@variables('database_schema')",
									"type": "Expression"
								}
							},
							"DeltaColumn": {
								"type": "String",
								"value": {
									"value": "@{activity('GetTableMetadata').output.firstRow.delta_column}",
									"type": "Expression"
								}
							},
							"GlobalTempTable": {
								"type": "String",
								"value": {
									"value": "@concat(pipeline().parameters.table_name,'_client_excls_tmp')",
									"type": "Expression"
								}
							},
							"LoadType": {
								"type": "String",
								"value": {
									"value": "@{activity('GetTableMetadata').output.firstRow.load_type}",
									"type": "Expression"
								}
							},
							"SourceName": {
								"type": "String",
								"value": {
									"value": "@pipeline().parameters.source",
									"type": "Expression"
								}
							},
							"TableName": {
								"type": "String",
								"value": {
									"value": "@{activity('GetTableMetadata').output.firstRow.table_name}",
									"type": "Expression"
								}
							},
							"PrimaryKeys": {
								"type": "String",
								"value": {
									"value": "@{activity('GetTableMetadata').output.firstRow.primary_key}",
									"type": "Expression"
								}
							}
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "Metastore",
						"type": "DatasetReference",
						"parameters": {
							"table_name": "''"
						}
					}
				}
			},
			{
				"name": "DateConditionalSet",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "GetColumns",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@empty(pipeline().parameters.date)",
						"type": "Expression"
					},
					"ifFalseActivities": [
						{
							"name": "SetCurrentTimestampFromParam_copy1",
							"type": "SetVariable",
							"dependsOn": [],
							"userProperties": [],
							"typeProperties": {
								"variableName": "date",
								"value": {
									"value": "@pipeline().parameters.date",
									"type": "Expression"
								}
							}
						}
					],
					"ifTrueActivities": [
						{
							"name": "SetCurrentTimestamp_copy1",
							"type": "SetVariable",
							"dependsOn": [],
							"userProperties": [],
							"typeProperties": {
								"variableName": "date",
								"value": {
									"value": "@utcnow()",
									"type": "Expression"
								}
							}
						}
					]
				}
			},
			{
				"name": "MasterRunIDSet",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "GetColumns",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@empty(pipeline().parameters.MasterRunID)",
						"type": "Expression"
					},
					"ifFalseActivities": [
						{
							"name": "SetMasterRunID_copy1",
							"type": "SetVariable",
							"dependsOn": [],
							"userProperties": [],
							"typeProperties": {
								"variableName": "MasterRunID",
								"value": {
									"value": "@pipeline().parameters.MasterRunID",
									"type": "Expression"
								}
							}
						}
					],
					"ifTrueActivities": [
						{
							"name": "SetCurrentMasterRunID_copy1",
							"type": "SetVariable",
							"dependsOn": [],
							"userProperties": [],
							"typeProperties": {
								"variableName": "MasterRunID",
								"value": {
									"value": "@pipeline().RunId",
									"type": "Expression"
								}
							}
						}
					]
				}
			},
			{
				"name": "SourceToTransient",
				"description": "fdfd",
				"type": "Copy",
				"dependsOn": [
					{
						"activity": "SendClientExemptionToSource",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "StageLoad",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "SetIndexInStaging",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "SqlMISource",
						"sqlReaderQuery": {
							"value": "@replace(replace(activity('Run_ClientExemptionSP').output.firstRow.query,'MaxTimestamp',activity('GetTableMetadata').output.firstRow.max_timestamp),'SourceTimestamp',variables('max_timestamp'))",
							"type": "Expression"
						},
						"partitionOption": "None"
					},
					"sink": {
						"type": "ParquetSink",
						"storeSettings": {
							"type": "AzureBlobFSWriteSettings",
							"blockSizeInMB": 100
						},
						"formatSettings": {
							"type": "ParquetWriteSettings"
						}
					},
					"enableStaging": false,
					"translator": {
						"type": "TabularTranslator",
						"typeConversion": true,
						"typeConversionSettings": {
							"allowDataTruncation": true,
							"treatBooleanAsNumber": false
						}
					}
				},
				"inputs": [
					{
						"referenceName": "parameterized_source",
						"type": "DatasetReference",
						"parameters": {
							"schema": {
								"value": "@variables('database_schema')",
								"type": "Expression"
							},
							"table_name": {
								"value": "@pipeline().parameters.table_name",
								"type": "Expression"
							},
							"server_path": {
								"value": "@variables('server_path')",
								"type": "Expression"
							},
							"database_name": {
								"value": "@variables('database_name')",
								"type": "Expression"
							}
						}
					}
				],
				"outputs": [
					{
						"referenceName": "caelum_data_lake",
						"type": "DatasetReference",
						"parameters": {
							"country": {
								"value": "@activity('GetTableMetadata').output.firstRow.country_name",
								"type": "Expression"
							},
							"zone": {
								"value": "@pipeline().globalParameters.transient_zone_name",
								"type": "Expression"
							},
							"source": {
								"value": "@pipeline().parameters.source",
								"type": "Expression"
							},
							"year": {
								"value": "@formatDateTime(variables('date'),'yyyy')",
								"type": "Expression"
							},
							"month": {
								"value": "@formatDateTime(variables('date'),'MM')",
								"type": "Expression"
							},
							"day": {
								"value": "@formatDateTime(variables('date'),'dd')",
								"type": "Expression"
							},
							"table": {
								"value": "@pipeline().parameters.table_name",
								"type": "Expression"
							},
							"file_timestamp": {
								"value": "@formatDateTime(variables('date'),'yyyyMMddhhmmss')",
								"type": "Expression"
							},
							"adls_dw_container_name": {
								"value": "@pipeline().globalParameters.adls_dw_container_name",
								"type": "Expression"
							}
						}
					}
				]
			},
			{
				"name": "UpdatePipelineLog",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "SourceToTransient",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "AzureSqlSource",
						"sqlReaderQuery": {
							"value": "INSERT INTO [dbo].[pipeline_log]\nSELECT '@{pipeline().DataFactory}' as DataFactory_Name,\n'@{pipeline().Pipeline}' as Pipeline_Name,\n'@{variables('MasterRunID')}' as RunId,\n'Source-To-@{pipeline().globalParameters.transient_zone_name}' as StepName,\n'source.@{pipeline().parameters.table_name}' as Source,\n'@{pipeline().globalParameters.transient_zone_name}.@{pipeline().parameters.table_name}' as Destination,\n'@{pipeline().TriggerType}' as TriggerType,\n'@{pipeline().TriggerId}' as TriggerId,\n'@{pipeline().TriggerName}' as TriggerName,\n'@{pipeline().TriggerTime}' as TriggerTime,\n'@{activity('SourceToTransient').output.rowsCopied}' as rowsCopied,\n'@{activity('SourceToTransient').output.rowsRead}' as RowsRead,\n'@{activity('SourceToTransient').output.usedParallelCopies}' as No_ParallelCopies,\n'@{activity('SourceToTransient').output.copyDuration}' as copyDuration_in_secs,\n'@{activity('SourceToTransient').output.effectiveIntegrationRuntime}' as effectiveIntegrationRuntime,\n'@{activity('SourceToTransient').output.executionDetails[0].source.type}' as Source_Type,\n'@{activity('SourceToTransient').output.executionDetails[0].sink.type}' as Sink_Type,\n'@{activity('SourceToTransient').output.executionDetails[0].status}' as Execution_Status,\n'@{activity('SourceToTransient').output.executionDetails[0].start}' as CopyActivity_Start_Time,\n'@{utcnow()}' as CopyActivity_End_Time,\n'@{activity('SourceToTransient').output.executionDetails[0].detailedDurations.queuingDuration}' as CopyActivity_queuingDuration_in_secs,\n'@{activity('SourceToTransient').output.executionDetails[0].detailedDurations.timeToFirstByte}' as CopyActivity_timeToFirstByte_in_secs,\n'@{activity('SourceToTransient').output.executionDetails[0].detailedDurations.transferDuration}' as CopyActivity_transferDuration_in_secs,\n'@{pipeline().parameters.table_name}' as table_name,\n'@{div(float(activity('SourceToTransient').output.dataWritten),1048576)}' as data_volume_mb\n--,' ' as output_url\nUNION\nSELECT '@{pipeline().DataFactory}' as DataFactory_Name,\n'@{pipeline().Pipeline}' as Pipeline_Name,\n'@{variables('MasterRunID')}' as RunId,\n'SourceCount' as StepName,\n'source.@{pipeline().parameters.table_name}' as Source,\n'@{pipeline().globalParameters.transient_zone_name}.@{pipeline().parameters.table_name}' as Destination,\n'@{pipeline().TriggerType}' as TriggerType,\n'@{pipeline().TriggerId}' as TriggerId,\n'@{pipeline().TriggerName}' as TriggerName,\n'@{pipeline().TriggerTime}' as TriggerTime,\n'NA' as rowsCopied,\n'@{variables('source_count')}' as RowsRead,\n'@{activity('SourceToTransient').output.usedParallelCopies}' as No_ParallelCopies,\n'@{activity('SourceToTransient').output.copyDuration}' as copyDuration_in_secs,\n'@{activity('SourceToTransient').output.effectiveIntegrationRuntime}' as effectiveIntegrationRuntime,\nCASE '@{activity('SourceToTransient').output.executionDetails[0].source.type}'\n\t\t\t\tWHEN 'AzureSqlMI' THEN 'SqlServer'\n\t\t\t\tWHEN 'SqlServer' THEN 'SqlServer'\n\t\t\t\tWHEN 'FileServer' THEN 'FileServer'\n\t\t\t\tWHEN 'SQLJSON' THEN 'SqlServer'\n\t\t\t\tWHEN 'RESTAPI' THEN 'RestApi'\n\t\t\t\tWHEN 'sqlserver' THEN 'SqlServer'\n\t\t\t\tWHEN 'ADLS' THEN 'AdlsGen2'\n\t\t\t\tWHEN 'adlsgen2' THEN 'AdlsGen2'\n\t\t\t\tWHEN 'AzureBlobFS' THEN 'AdlsGen2'\n\t\t\t\tWHEN 'sqldw' THEN 'SynapseSqlServer'\n\t\t\t\tWHEN '' THEN 'N/A'\n\t\t\t\tWHEN NULL THEN  'N/A'\n                ELSE '@{activity('SourceToTransient').output.executionDetails[0].source.type}'\n                END as Source_Type, \nCASE '@{activity('SourceToTransient').output.executionDetails[0].sink.type}' \n\t\t\t\tWHEN 'SqlServer' THEN 'SynapseSqlPool'\n\t\t\t\tWHEN 'adlsgen2' THEN 'AdlsGen2'\n\t\t\t\tWHEN 'AzureBlobFS' THEN 'AdlsGen2'\n\t\t\t\tWHEN 'sqldw' THEN 'SynapseSqlPool'\n\t\t\t\tWHEN '' THEN 'N/A'\n\t\t\t\tWHEN NULL THEN  'N/A'\n\t\t\t\tELSE '@{activity('SourceToTransient').output.executionDetails[0].sink.type}' \n                END\nas Sink_Type,\n'@{activity('SourceToTransient').output.executionDetails[0].status}' as Execution_Status,\n'@{activity('SourceToTransient').output.executionDetails[0].start}' as CopyActivity_Start_Time,\n'@{utcnow()}' as CopyActivity_End_Time,\n'@{activity('SourceToTransient').output.executionDetails[0].detailedDurations.queuingDuration}' as CopyActivity_queuingDuration_in_secs,\n'@{activity('SourceToTransient').output.executionDetails[0].detailedDurations.timeToFirstByte}' as CopyActivity_timeToFirstByte_in_secs,\n'@{activity('SourceToTransient').output.executionDetails[0].detailedDurations.transferDuration}' as CopyActivity_transferDuration_in_secs,\n'@{pipeline().parameters.table_name}' as table_name,\n'@{div(float(activity('SourceToTransient').output.dataWritten),1048576)}' as data_volume_mb\n;\nSELECT * FROM [dbo].[pipeline_log]\nWHERE pipeline_name='@{pipeline().RunId}'\n\n\n",
							"type": "Expression"
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "Log",
						"type": "DatasetReference",
						"parameters": {
							"table_name": "pipeline_log"
						}
					}
				}
			},
			{
				"name": "SendClientExemptionToSource",
				"type": "Copy",
				"dependsOn": [
					{
						"activity": "MasterRunIDSet",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "DateConditionalSet",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "If Condition1",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "Run_ClientExemptionSP",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "AzureSqlSource",
						"sqlReaderQuery": {
							"value": "SELECT *\nFROM dbo.client_exemption\nWHERE table_name='@{pipeline().parameters.table_name}'",
							"type": "Expression"
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"sink": {
						"type": "SqlServerSink",
						"preCopyScript": {
							"value": "IF OBJECT_ID('tempdb..##@{pipeline().parameters.table_name}_client_excls_tmp') IS NOT NULL\n\tDROP TABLE ##@{pipeline().parameters.table_name}_client_excls_tmp\n\nCREATE TABLE ##@{pipeline().parameters.table_name}_client_excls_tmp\n(\n\t[source] [varchar](200) NOT NULL,\n\t[table_name] [varchar](200) NOT NULL,\n\t[column_name] [varchar](200) NOT NULL,\n\t[value] [varchar](200) NULL\n) ON [PRIMARY];\n\nCREATE CLUSTERED INDEX @{pipeline().parameters.table_name}_t_index\n ON ##@{pipeline().parameters.table_name}_client_excls_tmp\n  ([column_name],[value])",
							"type": "Expression"
						}
					},
					"enableStaging": false,
					"translator": {
						"type": "TabularTranslator",
						"typeConversion": true,
						"typeConversionSettings": {
							"allowDataTruncation": true,
							"treatBooleanAsNumber": false
						}
					}
				},
				"inputs": [
					{
						"referenceName": "Log",
						"type": "DatasetReference",
						"parameters": {
							"table_name": "''"
						}
					}
				],
				"outputs": [
					{
						"referenceName": "parameterized_source",
						"type": "DatasetReference",
						"parameters": {
							"schema": {
								"value": "@variables('database_schema')",
								"type": "Expression"
							},
							"table_name": {
								"value": "@concat('##',pipeline().parameters.table_name,'_client_excls_tmp')",
								"type": "Expression"
							},
							"server_path": {
								"value": "@variables('server_path')",
								"type": "Expression"
							},
							"database_name": {
								"value": "@variables('database_name')",
								"type": "Expression"
							}
						}
					}
				]
			},
			{
				"name": "CleanTempTable",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "SourceToTransient",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "SqlServerSource",
						"sqlReaderQuery": {
							"value": "IF OBJECT_ID(N'tempdb..@{concat('##',pipeline().parameters.table_name,'_client_excls_tmp')}', N'U') IS NOT NULL  \n   DROP TABLE @{concat('##',pipeline().parameters.table_name,'_client_excls_tmp')};  \nSELECT 1",
							"type": "Expression"
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "parameterized_source",
						"type": "DatasetReference",
						"parameters": {
							"schema": {
								"value": "@variables('database_schema')",
								"type": "Expression"
							},
							"table_name": {
								"value": "@concat('##',pipeline().parameters.table_name,'_client_excls_tmp')",
								"type": "Expression"
							},
							"server_path": {
								"value": "@variables('server_path')",
								"type": "Expression"
							},
							"database_name": {
								"value": "@variables('database_name')",
								"type": "Expression"
							}
						}
					}
				}
			},
			{
				"name": "SetErrorBranchSuccess",
				"type": "SetVariable",
				"dependsOn": [
					{
						"activity": "CheckTechnicalColsPresence",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"variableName": "success_branch",
					"value": {
						"value": "@{activity('CheckTechnicalColsPresence').output.firstRow.counter}",
						"type": "Expression"
					}
				}
			},
			{
				"name": "If Condition1",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "SetErrorBranchSuccess",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@not(equals(variables('success_branch'),'0'))",
						"type": "Expression"
					},
					"ifFalseActivities": [
						{
							"name": "Set max_timestamp Failure",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "GetSourceMaxTimestampFailure",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "max_timestamp",
								"value": {
									"value": "@activity('GetSourceMaxTimestampFailure').output.firstRow.timestamp",
									"type": "Expression"
								}
							}
						},
						{
							"name": "Set max_index Failure",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "Set max_timestamp Failure",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "max_index",
								"value": {
									"value": "@string(activity('GetSourceMaxTimestampFailure').output.firstRow.max_index)",
									"type": "Expression"
								}
							}
						},
						{
							"name": "Set max_source_count Failure",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "Set max_index Failure",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "source_count",
								"value": {
									"value": "@string(activity('GetSourceMaxTimestampFailure').output.firstRow.counter)",
									"type": "Expression"
								}
							}
						},
						{
							"name": "GetSourceMaxTimestampFailure",
							"type": "Lookup",
							"dependsOn": [],
							"policy": {
								"timeout": "7.00:00:00",
								"retry": 0,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"typeProperties": {
								"source": {
									"type": "SqlMISource",
									"sqlReaderQuery": {
										"value": "SELECT count_big(1) max_index, COUNT(1) counter, CURRENT_TIMESTAMP timestamp\nFROM @{variables('database_name')}.@{variables('database_schema')}.@{pipeline().parameters.table_name}\n",
										"type": "Expression"
									},
									"partitionOption": "None"
								},
								"dataset": {
									"referenceName": "parameterized_source",
									"type": "DatasetReference",
									"parameters": {
										"schema": {
											"value": "@variables('database_schema')",
											"type": "Expression"
										},
										"table_name": {
											"value": "@pipeline().parameters.table_name",
											"type": "Expression"
										},
										"server_path": {
											"value": "@variables('server_path')",
											"type": "Expression"
										},
										"database_name": {
											"value": "@variables('database_name')",
											"type": "Expression"
										}
									}
								}
							}
						}
					],
					"ifTrueActivities": [
						{
							"name": "Set max_timestamp Success",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "GetSourceMaxTimestampSuccess",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "max_timestamp",
								"value": {
									"value": "@activity('GetSourceMaxTimestampSuccess').output.firstRow.timestamp",
									"type": "Expression"
								}
							}
						},
						{
							"name": "Set max_index Success",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "Set max_timestamp Success",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "max_index",
								"value": {
									"value": "@string(activity('GetSourceMaxTimestampSuccess').output.firstRow.max_index)",
									"type": "Expression"
								}
							}
						},
						{
							"name": "Set max_source_count Success",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "Set max_index Success",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "source_count",
								"value": {
									"value": "@string(activity('GetSourceMaxTimestampSuccess').output.firstRow.counter)",
									"type": "Expression"
								}
							}
						},
						{
							"name": "GetSourceMaxTimestampSuccess",
							"type": "Lookup",
							"dependsOn": [],
							"policy": {
								"timeout": "7.00:00:00",
								"retry": 0,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"typeProperties": {
								"source": {
									"type": "SqlMISource",
									"sqlReaderQuery": {
										"value": "SELECT *\nFROM (SELECT COALESCE(max(@{if(and(equals(activity('GetTableMetadata').output.firstRow.load_type, 'historical'),equals(activity('GetTableMetadata').output.firstRow.source_name, 'NOVA')),'SOURCE_CREATED_DATETIME',activity('GetTableMetadata').output.firstRow.delta_column)}), '@{activity('GetTableMetadata').output.firstRow.max_timestamp}' ) timestamp,\nCOALESCE(max(@{activity('GetTableMetadata').output.firstRow.index_column}),0)+@{activity('GetTableMetadata').output.firstRow.max_index} max_index\nFROM @{variables('database_name')}.@{variables('database_schema')}.@{activity('GetTableMetadata').output.firstRow.table_name}\n) l \nJOIN (\nSELECT COUNT(1) counter\nFROM @{variables('database_name')}.@{variables('database_schema')}.@{activity('GetTableMetadata').output.firstRow.table_name}\nWHERE @{if(and(equals(activity('GetTableMetadata').output.firstRow.load_type, 'historical'),equals(activity('GetTableMetadata').output.firstRow.source_name, 'NOVA')),'SOURCE_CREATED_DATETIME',activity('GetTableMetadata').output.firstRow.delta_column)} BETWEEN \n'@{activity('GetTableMetadata').output.firstRow.max_timestamp}' AND (SELECT COALESCE(max(@{if(and(equals(activity('GetTableMetadata').output.firstRow.load_type, 'historical'),equals(activity('GetTableMetadata').output.firstRow.source_name, 'NOVA')),'SOURCE_CREATED_DATETIME',activity('GetTableMetadata').output.firstRow.delta_column)}), '@{activity('GetTableMetadata').output.firstRow.max_timestamp}' ) FROM @{variables('database_name')}.@{variables('database_schema')}.@{activity('GetTableMetadata').output.firstRow.table_name})) r\nON 1=1\n",
										"type": "Expression"
									},
									"partitionOption": "None"
								},
								"dataset": {
									"referenceName": "parameterized_source",
									"type": "DatasetReference",
									"parameters": {
										"schema": {
											"value": "@variables('database_schema')",
											"type": "Expression"
										},
										"table_name": {
											"value": "@pipeline().parameters.table_name",
											"type": "Expression"
										},
										"server_path": {
											"value": "@variables('server_path')",
											"type": "Expression"
										},
										"database_name": {
											"value": "@variables('database_name')",
											"type": "Expression"
										}
									}
								}
							}
						}
					]
				}
			},
			{
				"name": "CheckTechnicalColsPresence",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "SetDatabaseForLoad",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "SetServerForLoad",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "SqlMISource",
						"sqlReaderQuery": {
							"value": "SELECT count(1) as counter from INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_NAME = '@{activity('GetTableMetadata').output.firstRow.table_name}' \nAND TABLE_SCHEMA = '@{variables('database_schema')}' \nAND COLUMN_NAME = 'ROW_ID'",
							"type": "Expression"
						},
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "parameterized_source",
						"type": "DatasetReference",
						"parameters": {
							"schema": {
								"value": "@variables('database_schema')",
								"type": "Expression"
							},
							"table_name": {
								"value": "@pipeline().parameters.table_name",
								"type": "Expression"
							},
							"server_path": {
								"value": "@variables('server_path')",
								"type": "Expression"
							},
							"database_name": {
								"value": "@variables('database_name')",
								"type": "Expression"
							}
						}
					}
				}
			},
			{
				"name": "GatherTestingParameters",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "UpdateMetadata",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "AzureSqlSource",
						"sqlReaderQuery": {
							"value": "INSERT INTO [tst].[testing_parameters]\nSELECT '@{variables('MasterRunID')}' as run_id,\n'@{pipeline().parameters.testing_run_id}' as iterator_run_id,\n'@{pipeline().parameters.table_name}' as table_name,\n'@{pipeline().parameters.source}' as source,\n'@{pipeline().parameters.table_name}*' as filename,\n'@{formatDateTime(variables('date'),'dd')}' as day,\n'@{formatDateTime(variables('date'),'MM')}' as month,\n'@{formatDateTime(variables('date'),'yyyy')}' as year,\n(SELECT aggregate_key from tst.configs\nwhere TABLE_NAME = '@{pipeline().parameters.table_name}') as aggregateKey,\n'@{variables('max_timestamp')}' as source_max,\n'@{activity('GetTableMetadata').output.firstRow.max_timestamp}' as current_max,\n'@{activity('GetTableMetadata').output.firstRow.system_db_schema}' as system_db_schema,\n'@{activity('GetTableMetadata').output.firstRow.system_db}' as system_db,\n'@{activity('GetTableMetadata').output.firstRow.system_url}' as system_url,\n'@{if(and(equals(activity('GetTableMetadata').output.firstRow.load_type, 'historical'),equals(activity('GetTableMetadata').output.firstRow.source_name, 'NOVA')),'SOURCE_CREATED_DATETIME',activity('GetTableMetadata').output.firstRow.delta_column)}' as delta_column\n;\nSELECT * FROM [tst].[testing_parameters]\nWHERE run_id='@{pipeline().RunId}'",
							"type": "Expression"
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "Log",
						"type": "DatasetReference",
						"parameters": {
							"table_name": "testing_parameters"
						}
					}
				}
			},
			{
				"name": "IfSourceIsNovaRunClientExemptionPipe",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "GetTableMetadata",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@and(equals(activity('GetTableMetadata').output.firstRow.source_name,'NOVA'),equals(activity('GetTableMetadata').output.firstRow.exclusion_flg,true))",
						"type": "Expression"
					},
					"ifTrueActivities": [
						{
							"name": "ExecuteIncrClientExemption",
							"type": "ExecutePipeline",
							"dependsOn": [],
							"userProperties": [],
							"typeProperties": {
								"pipeline": {
									"referenceName": "client_exclusion_incr_ForLoop",
									"type": "PipelineReference"
								},
								"waitOnCompletion": true,
								"parameters": {
									"filtertableForExclusion": {
										"value": "@activity('GetTableMetadata').output.firstRow.table_name",
										"type": "Expression"
									}
								}
							}
						}
					]
				}
			},
			{
				"name": "StageLoad",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "If Condition1",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "MasterRunIDSet",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "DateConditionalSet",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@and(equals(pipeline().parameters.source,'NOVA'),equals(activity('GetTableMetadata').output.firstRow.load_type,'incremental'))",
						"type": "Expression"
					},
					"ifTrueActivities": [
						{
							"name": "StageLoadCopy",
							"type": "Copy",
							"dependsOn": [],
							"policy": {
								"timeout": "7.00:00:00",
								"retry": 0,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"typeProperties": {
								"source": {
									"type": "SqlServerSource",
									"sqlReaderQuery": {
										"value": "SELECT *\nFROM @{variables('database_name')}.@{variables('database_schema')}.@{pipeline().parameters.table_name} WITH (NOLOCK) \nWHERE ROW_CREATED_DATETIME BETWEEN '@{activity('GetTableMetadata').output.firstRow.max_timestamp}'\nAND '@{variables('max_timestamp')}'",
										"type": "Expression"
									},
									"queryTimeout": "02:00:00",
									"partitionOption": "None"
								},
								"sink": {
									"type": "SqlServerSink",
									"writeBehavior": "insert",
									"sqlWriterUseTableLock": false,
									"tableOption": "autoCreate"
								},
								"enableStaging": false,
								"translator": {
									"type": "TabularTranslator",
									"typeConversion": true,
									"typeConversionSettings": {
										"allowDataTruncation": true,
										"treatBooleanAsNumber": false
									}
								}
							},
							"inputs": [
								{
									"referenceName": "parameterized_source",
									"type": "DatasetReference",
									"parameters": {
										"schema": {
											"value": "@variables('database_schema')",
											"type": "Expression"
										},
										"table_name": {
											"value": "@pipeline().parameters.table_name",
											"type": "Expression"
										},
										"server_path": {
											"value": "@variables('server_path')",
											"type": "Expression"
										},
										"database_name": {
											"value": "@variables('database_name')",
											"type": "Expression"
										}
									}
								}
							],
							"outputs": [
								{
									"referenceName": "parameterized_source",
									"type": "DatasetReference",
									"parameters": {
										"schema": {
											"value": "staging",
											"type": "Expression"
										},
										"table_name": {
											"value": "@pipeline().parameters.table_name",
											"type": "Expression"
										},
										"server_path": {
											"value": "@variables('server_path')",
											"type": "Expression"
										},
										"database_name": {
											"value": "CaelumStagingDb",
											"type": "Expression"
										}
									}
								}
							]
						},
						{
							"name": "SetNewSchema",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "StageLoadCopy",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "database_schema",
								"value": "staging"
							}
						},
						{
							"name": "SetNewDatabase",
							"type": "SetVariable",
							"dependsOn": [
								{
									"activity": "StageLoadCopy",
									"dependencyConditions": [
										"Succeeded"
									]
								}
							],
							"userProperties": [],
							"typeProperties": {
								"variableName": "database_name",
								"value": {
									"value": "CaelumStagingDb",
									"type": "Expression"
								}
							}
						}
					]
				}
			},
			{
				"name": "SetIndexInStaging",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "Run_ClientExemptionSP",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "7.00:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "SqlServerSource",
						"sqlReaderQuery": {
							"value": "@concat(\n    if(\n        and(\n                equals(\n                        variables('database_name'),\n                        'CaelumStagingDb'\n                ),\n                equals(\n                        variables('database_schema'),\n                        'staging'\n                )\n        \n        ),\n        concat(\n                activity('Run_ClientExemptionSP').output.firstRow.index_query,\n                ';'\n                )\n        ,''\n        ),\n'SELECT 1')",
							"type": "Expression"
						},
						"queryTimeout": "02:00:00",
						"partitionOption": "None"
					},
					"dataset": {
						"referenceName": "parameterized_source",
						"type": "DatasetReference",
						"parameters": {
							"schema": {
								"value": "@variables('database_schema')",
								"type": "Expression"
							},
							"table_name": {
								"value": "@pipeline().parameters.table_name",
								"type": "Expression"
							},
							"server_path": {
								"value": "@variables('server_path')",
								"type": "Expression"
							},
							"database_name": {
								"value": "@variables('database_name')",
								"type": "Expression"
							}
						}
					}
				}
			}
		],
		"parameters": {
			"table_name": {
				"type": "string",
				"defaultValue": "NOVA_ncGrupp"
			},
			"source": {
				"type": "string",
				"defaultValue": "NOVA"
			},
			"date": {
				"type": "string"
			},
			"MasterRunID": {
				"type": "string"
			},
			"testing_run_id": {
				"type": "string"
			},
			"catchup": {
				"type": "string",
				"defaultValue": "false"
			}
		},
		"variables": {
			"date": {
				"type": "String"
			},
			"server_path": {
				"type": "String"
			},
			"database_name": {
				"type": "String"
			},
			"MasterRunID": {
				"type": "String"
			},
			"database_schema": {
				"type": "String"
			},
			"transient_record_count": {
				"type": "String",
				"defaultValue": "0"
			},
			"max_timestamp": {
				"type": "String"
			},
			"max_index": {
				"type": "String"
			},
			"source_count": {
				"type": "String"
			},
			"success_branch": {
				"type": "String",
				"defaultValue": "'False'"
			}
		},
		"folder": {
			"name": "Caelum_Pipelines/1 source_to_transient"
		},
		"annotations": [],
		"lastPublishTime": "2021-06-14T09:09:15Z"
	},
	"type": "Microsoft.DataFactory/factories/pipelines"
}